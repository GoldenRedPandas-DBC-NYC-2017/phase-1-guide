Here is a list of the key challenges from the first week.  Review the list and use this weekend to solo on any you struggled with.

Good luck with Sudoku!

#### Key Challenges

##### [Debugging Drill Read The Error](../../../../debugging-drill-read-the-error-challenge)

Why? Good debugging skills are invaluable. You're going to break all sorts of things as a programmer and you need to be able to evaluate a system and chip away at a problem in an organized fashion if you're going to make any progress. Poor debugging skills are often the sign of a lack of understanding of fundamentals. Never take the approach of just trying things without any rhyme or reason. Take your hands off the keyboard and think for a moment: What am I seeing? Do I have enough information? How can I get more? What am I expecting? What should I change?

##### [Design Drill Code Style](../../../../design-drill-code-style-challenge)

Poor indentation, variable naming, non-idiomatic coding styles make reading code like trying to read a crumpled up piece of paper. Indentation should ALWAYS be consistent, variable names should be as precise and accurate as possible. Anything less shows the reader of your code you don't really care about your work. Keep your code clean and act like a professional. You might be a junior developer, but there's no reason you can't dress like a senior one.

##### [Design Drill Translate To Pseudocode](../../../../design-drill-translate-to-pseudocode-challenge)

This is an exercise in reading and understanding code. You'll use this skill on a daily basis. The translation from code to english and english to code can be a tricky one, but with practice you'll become fluent.

##### [Ruby Drill Enumerable Methods](../../../../ruby-drill-enumerable-methods-challenge)

Ruby's enumerable methods are A-mazing. Get to know them well and start thinking like an enumerable-ist. After syntax, writing idiomatic Ruby requires a strong familiarity with the Enumerable module.

##### [Algorithm Drill Factorial](../../../../algorithm-drill-factorial-challenge)

This challenge is a straightforward challenge where you'll write both the iterative approach and recursive approach to solving a problem. If you're struggling with recursion, do this a few times in a row. Breaking for longer periods before redoing the challenge (e.g. 15min, then 45min then 3h).

##### [Anagrams 1 Detecting Anagrams](../../../../anagrams-1-detecting-anagrams-challenge)

In this challenge transitioning from a brute force approach to finding anagrams to a determining the canonical representation of a string is a great example of distilling down what really needs to be done to solve a problem. The leap from a simple solution to a clever one isn't always necessary, but it's one of the joys of programming.

##### [Nested Arrays 2 Ruby For Conversion And Seeding](../../../../nested-arrays-2-ruby-for-conversion-and-seeding-challenge)

You'll working with Arrays and Hashes until you give up software development and open a B&B in Vermont. So get to know these data structures! Know when to use one or the other, know their limitations, their strengths and be very familiar with their practical usage in Ruby.

##### [Ruby Racer 1 Outrageous Fortune](../../../../ruby-racer-1-outrageous-fortune-challenge)

This challenge requires you to model state in a data structure of your choosing and modify that state over time. It also includes a chance to give thought to separating the state of a system and how you present that state. More specifically, how tightly to you couple the state of the game and the requirements related to printing the game's state on the screen? Hopefully without any coupling at all!
